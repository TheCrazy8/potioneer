// Hunger Bens .ben Plugin Builder
// Client-side application for creating plugin archives

(function() {
  'use strict';

  // ========================================
  // State Management
  // ========================================
  
  const state = {
    currentTab: 'quick',
    fileTree: {},
    currentEditingFile: null
  };

  // ========================================
  // Utility Functions
  // ========================================

  function showMessage(message, type = 'info') {
    const area = document.getElementById('message-area');
    const msgDiv = document.createElement('div');
    msgDiv.className = `message ${type}`;
    
    msgDiv.innerHTML = `
      <div class="message-header">
        ${type === 'success' ? '✅' : type === 'error' ? '❌' : '⚠️'} ${type.toUpperCase()}
        <button class="message-close">&times;</button>
      </div>
      <div>${message}</div>
    `;
    
    area.appendChild(msgDiv);
    
    msgDiv.querySelector('.message-close').addEventListener('click', () => {
      msgDiv.remove();
    });
    
    // Auto-remove after 5 seconds
    setTimeout(() => msgDiv.remove(), 5000);
  }

  function validateJSON(text) {
    if (!text.trim()) {
      return { valid: true, data: null };
    }
    try {
      const data = JSON.parse(text);
      return { valid: true, data };
    } catch (e) {
      return { valid: false, error: e.message };
    }
  }

  function sanitizeFilename(name) {
    return name.replace(/[^a-zA-Z0-9_\-\.]/g, '_');
  }

  function validatePluginStructure(fileTree) {
    // Check for valid entry points
    const hasRootPluginPy = 'plugin.py' in fileTree;
    const hasPackageInit = 'plugin' in fileTree && 
                          typeof fileTree['plugin'] === 'object' &&
                          '__init__.py' in fileTree['plugin'];
    
    // Count root-level .py files
    const rootPyFiles = Object.keys(fileTree).filter(k => 
      typeof fileTree[k] === 'string' && k.endsWith('.py')
    );
    
    if (hasRootPluginPy) {
      return { valid: true, entry: 'plugin.py' };
    }
    if (hasPackageInit) {
      return { valid: true, entry: 'plugin/__init__.py' };
    }
    if (rootPyFiles.length === 1) {
      return { valid: true, entry: rootPyFiles[0] };
    }
    
    return { 
      valid: false, 
      error: 'No valid entry point found. Need plugin.py, plugin/__init__.py, or exactly one .py file at root.'
    };
  }

  // ========================================
  // Code Generation
  // ========================================

  function generatePluginHeader(metadata) {
    const { id, author, description, license } = metadata;
    let header = '"""\n';
    header += 'Generated by Hunger Bens .ben Builder\n';
    header += 'https://thecrazy8.github.io/hunger-bens/ben-generator/\n\n';
    
    if (id) header += `Plugin ID: ${id}\n`;
    if (author) header += `Author: ${author}\n`;
    if (description) header += `Description: ${description}\n`;
    if (license) header += `License: ${license}\n`;
    
    header += '\n';
    header += 'Plugin API Functions (optional):\n';
    header += '  - get_custom_content() -> dict\n';
    header += '  - get_events() -> {"day": [callable], "night": [callable], "global": [callable]}\n';
    header += '  - get_event_weights() -> {callable or callable_name: float}\n';
    header += '"""\n\n';
    
    return header;
  }

  function generateCustomContentFunction(weapons, items, hazards) {
    if (!weapons && !items && !hazards) {
      return '';
    }

    let code = 'def get_custom_content():\n';
    code += '    """Provide custom weapons, items, and hazards."""\n';
    code += '    return {\n';
    
    if (weapons) {
      code += '        "weapons": ' + JSON.stringify(weapons, null, 12).replace(/\n/g, '\n        ') + ',\n';
    }
    if (items) {
      code += '        "items": ' + JSON.stringify(items, null, 12).replace(/\n/g, '\n        ') + ',\n';
    }
    if (hazards) {
      code += '        "hazards": ' + JSON.stringify(hazards, null, 12).replace(/\n/g, '\n        ') + ',\n';
    }
    
    code += '    }\n\n';
    return code;
  }

  function generateSampleEvent() {
    return `
def sample_event(tributes, rng, sim):
    """Example custom event - modify as needed.
    
    Args:
        tributes: List of alive tribute objects
        rng: random.Random instance for reproducibility
        sim: Simulator instance (access to game state)
    
    Returns:
        List of narrative strings to log
    """
    try:
        if not tributes:
            return []
        
        t = rng.choice(tributes)
        
        # Example: small morale adjustment
        if hasattr(t, 'adjust_morale'):
            t.adjust_morale(1)
        
        return [f"{getattr(t, 'name', 'A tribute')} finds a mysterious object and feels slightly braver."]
    except Exception as e:
        # Defensive coding: don't crash the simulation
        return [f"[Event Error: {e}]"]


def get_events():
    """Register custom events by phase.
    
    Returns:
        Dict with keys: "day", "night", "global"
        Each value is a list of event callables
    """
    return {
        "day": [sample_event],
        "night": [],
        "global": []
    }


def get_event_weights():
    """Define relative frequencies for custom events.
    
    Returns:
        Dict mapping event functions (or names) to weights (float)
        Base game weights range ~0.5-1.3
    """
    return {
        sample_event: 0.8,
        # Or use string name: "sample_event": 0.8
    }
`;
  }

  function generatePluginCode(options) {
    const {
      metadata,
      customContent,
      includeSampleEvent
    } = options;

    let code = generatePluginHeader(metadata);
    
    // Imports
    code += 'from typing import Any, Dict, List, Callable\n';
    code += 'import random\n\n';
    
    // Optional metadata
    if (metadata.id) {
      code += `PLUGIN_NAME = "${metadata.id}"\n`;
    }
    if (metadata.author) {
      code += `PLUGIN_AUTHOR = "${metadata.author}"\n`;
    }
    code += '\n';
    
    // Custom content function
    if (customContent.weapons || customContent.items || customContent.hazards) {
      code += generateCustomContentFunction(
        customContent.weapons,
        customContent.items,
        customContent.hazards
      );
    }
    
    // Sample event
    if (includeSampleEvent) {
      code += generateSampleEvent();
    }
    
    // Self-check
    code += '\n';
    code += 'if __name__ == "__main__":\n';
    code += `    print("Plugin: ${metadata.id || 'Unnamed'}")\n`;
    if (customContent.weapons || customContent.items || customContent.hazards) {
      code += '    print("Custom content:", get_custom_content())\n';
    }
    if (includeSampleEvent) {
      code += '    print("Events:", get_events())\n';
      code += '    print("Weights:", get_event_weights())\n';
    }
    
    return code;
  }

  // ========================================
  // Quick Builder Functions
  // ========================================

  function collectQuickBuilderData() {
    const pluginId = document.getElementById('plugin-id').value.trim();
    const author = document.getElementById('plugin-author').value.trim();
    const description = document.getElementById('plugin-description').value.trim();
    const license = document.getElementById('plugin-license').value.trim();
    const entryType = document.querySelector('input[name="entry-type"]:checked').value;
    
    // Validate required fields
    if (!pluginId) {
      showMessage('Plugin ID is required', 'error');
      return null;
    }
    
    // Custom content JSON validation
    const weaponsText = document.getElementById('custom-weapons').value.trim();
    const itemsText = document.getElementById('custom-items').value.trim();
    const hazardsText = document.getElementById('custom-hazards').value.trim();
    
    const weaponsResult = validateJSON(weaponsText);
    if (!weaponsResult.valid) {
      showMessage(`Invalid Weapons JSON: ${weaponsResult.error}`, 'error');
      return null;
    }
    
    const itemsResult = validateJSON(itemsText);
    if (!itemsResult.valid) {
      showMessage(`Invalid Items JSON: ${itemsResult.error}`, 'error');
      return null;
    }
    
    const hazardsResult = validateJSON(hazardsText);
    if (!hazardsResult.valid) {
      showMessage(`Invalid Hazards JSON: ${hazardsResult.error}`, 'error');
      return null;
    }
    
    const includeSampleEvent = document.getElementById('include-sample-event').checked;
    const includeReadme = document.getElementById('include-readme').checked;
    const includeLicenseFile = document.getElementById('include-license-file').checked;
    
    return {
      metadata: { id: pluginId, author, description, license },
      entryType,
      customContent: {
        weapons: weaponsResult.data,
        items: itemsResult.data,
        hazards: hazardsResult.data
      },
      includeSampleEvent,
      includeReadme,
      includeLicenseFile
    };
  }

  function buildQuickPlugin() {
    const data = collectQuickBuilderData();
    if (!data) return;
    
    const { metadata, entryType, customContent, includeSampleEvent, includeReadme, includeLicenseFile } = data;
    
    // Generate plugin code
    const pluginCode = generatePluginCode({
      metadata,
      customContent,
      includeSampleEvent
    });
    
    // Create file tree
    const fileTree = {};
    
    if (entryType === 'single') {
      fileTree['plugin.py'] = pluginCode;
    } else {
      fileTree['plugin'] = {
        '__init__.py': pluginCode
      };
    }
    
    // Add README if requested
    if (includeReadme) {
      let readme = `${metadata.id || 'Plugin'}\n`;
      readme += '='.repeat(metadata.id?.length || 6) + '\n\n';
      if (metadata.description) {
        readme += metadata.description + '\n\n';
      }
      if (metadata.author) {
        readme += `Author: ${metadata.author}\n`;
      }
      readme += '\nInstallation\n------------\n';
      readme += 'Copy this .ben file to one of these locations:\n';
      readme += '  - %LOCALAPPDATA%\\HungerBens\\plugins\n';
      readme += '  - %APPDATA%\\HungerBens\\plugins\n';
      readme += '  - %PROGRAMDATA%\\HungerBens\\plugins\n';
      readme += '\nThen run the simulator with plugins enabled in Settings.\n';
      
      fileTree['README.txt'] = readme;
    }
    
    // Add LICENSE if requested
    if (includeLicenseFile && metadata.license) {
      fileTree['LICENSE.txt'] = `${metadata.license}\n\n(License text should be added here)`;
    }
    
    // Build and download
    buildAndDownload(fileTree, sanitizeFilename(metadata.id));
  }

  function previewQuickPlugin() {
    const data = collectQuickBuilderData();
    if (!data) return;
    
    const { metadata, customContent, includeSampleEvent } = data;
    
    const code = generatePluginCode({
      metadata,
      customContent,
      includeSampleEvent
    });
    
    showPreviewModal(code);
  }

  // ========================================
  // Advanced Builder Functions
  // ========================================

  function renderFileTree() {
    const container = document.getElementById('file-tree');
    
    if (Object.keys(state.fileTree).length === 0) {
      container.innerHTML = '<div class="empty-tree">No files yet. Add files or folders to get started.</div>';
      return;
    }
    
    container.innerHTML = '';
    renderFileTreeRecursive(container, state.fileTree, '');
  }

  function renderFileTreeRecursive(container, tree, path) {
    const entries = Object.entries(tree).sort((a, b) => {
      // Folders first, then files
      const aIsFolder = typeof a[1] === 'object';
      const bIsFolder = typeof b[1] === 'object';
      if (aIsFolder && !bIsFolder) return -1;
      if (!aIsFolder && bIsFolder) return 1;
      return a[0].localeCompare(b[0]);
    });
    
    for (const [name, content] of entries) {
      const fullPath = path ? `${path}/${name}` : name;
      const isFolder = typeof content === 'object';
      
      const item = document.createElement('div');
      item.className = `file-tree-item ${isFolder ? 'folder' : 'file'}`;
      
      const indent = path.split('/').length * 20;
      item.style.paddingLeft = `${indent + 8}px`;
      
      item.innerHTML = `
        <div class="file-info">
          <span class="file-icon">${isFolder ? '📁' : '📄'}</span>
          <span>${name}</span>
        </div>
        <div class="file-actions">
          ${!isFolder ? '<button class="edit-btn" title="Edit">✏️</button>' : ''}
          <button class="rename-btn" title="Rename">✎</button>
          <button class="delete-btn" title="Delete">🗑️</button>
        </div>
      `;
      
      if (!isFolder) {
        item.querySelector('.edit-btn').addEventListener('click', (e) => {
          e.stopPropagation();
          editFile(fullPath);
        });
      }
      
      item.querySelector('.rename-btn').addEventListener('click', (e) => {
        e.stopPropagation();
        renameItem(fullPath);
      });
      
      item.querySelector('.delete-btn').addEventListener('click', (e) => {
        e.stopPropagation();
        deleteItem(fullPath);
      });
      
      container.appendChild(item);
      
      if (isFolder) {
        renderFileTreeRecursive(container, content, fullPath);
      }
    }
  }

  function addFile() {
    const filename = prompt('Enter filename (e.g., my_events.py):');
    if (!filename) return;
    
    const sanitized = sanitizeFilename(filename);
    if (sanitized in state.fileTree) {
      showMessage('File already exists', 'error');
      return;
    }
    
    state.fileTree[sanitized] = '';
    renderFileTree();
    editFile(sanitized);
  }

  function addFolder() {
    const foldername = prompt('Enter folder name:');
    if (!foldername) return;
    
    const sanitized = sanitizeFilename(foldername);
    if (sanitized in state.fileTree) {
      showMessage('Folder already exists', 'error');
      return;
    }
    
    state.fileTree[sanitized] = {};
    renderFileTree();
    showMessage(`Folder "${sanitized}" created`, 'success');
  }

  function uploadFiles() {
    document.getElementById('file-upload-input').click();
  }

  function handleFileUpload(event) {
    const files = Array.from(event.target.files);
    
    Promise.all(files.map(file => {
      return new Promise((resolve) => {
        const reader = new FileReader();
        reader.onload = (e) => {
          resolve({
            name: file.name,
            content: e.target.result
          });
        };
        reader.readAsText(file);
      });
    })).then(results => {
      results.forEach(({ name, content }) => {
        state.fileTree[sanitizeFilename(name)] = content;
      });
      renderFileTree();
      showMessage(`Uploaded ${results.length} file(s)`, 'success');
    });
    
    // Reset input
    event.target.value = '';
  }

  function editFile(path) {
    const content = getFileContent(path);
    if (content === null) {
      showMessage('File not found', 'error');
      return;
    }
    
    state.currentEditingFile = path;
    document.getElementById('current-file-name').textContent = path;
    document.getElementById('file-editor').value = content;
    document.getElementById('file-editor-section').style.display = 'block';
    
    // Scroll to editor
    document.getElementById('file-editor-section').scrollIntoView({ behavior: 'smooth' });
  }

  function saveFile() {
    if (!state.currentEditingFile) return;
    
    const content = document.getElementById('file-editor').value;
    setFileContent(state.currentEditingFile, content);
    
    document.getElementById('file-editor-section').style.display = 'none';
    state.currentEditingFile = null;
    
    renderFileTree();
    showMessage('File saved', 'success');
  }

  function cancelEdit() {
    document.getElementById('file-editor-section').style.display = 'none';
    state.currentEditingFile = null;
  }

  function renameItem(path) {
    const parts = path.split('/');
    const oldName = parts[parts.length - 1];
    const newName = prompt(`Rename "${oldName}" to:`, oldName);
    
    if (!newName || newName === oldName) return;
    
    const sanitized = sanitizeFilename(newName);
    const parentPath = parts.slice(0, -1).join('/');
    const parent = parentPath ? getFileContent(parentPath) : state.fileTree;
    
    if (sanitized in parent) {
      showMessage('Name already exists', 'error');
      return;
    }
    
    parent[sanitized] = parent[oldName];
    delete parent[oldName];
    
    renderFileTree();
    showMessage('Renamed successfully', 'success');
  }

  function deleteItem(path) {
    if (!confirm(`Delete "${path}"?`)) return;
    
    const parts = path.split('/');
    const name = parts[parts.length - 1];
    const parentPath = parts.slice(0, -1).join('/');
    const parent = parentPath ? getFileContent(parentPath) : state.fileTree;
    
    delete parent[name];
    
    renderFileTree();
    showMessage('Deleted successfully', 'success');
  }

  function getFileContent(path) {
    const parts = path.split('/');
    let current = state.fileTree;
    
    for (let i = 0; i < parts.length; i++) {
      if (!(parts[i] in current)) return null;
      current = current[parts[i]];
    }
    
    return current;
  }

  function setFileContent(path, content) {
    const parts = path.split('/');
    let current = state.fileTree;
    
    for (let i = 0; i < parts.length - 1; i++) {
      if (!(parts[i] in current)) return false;
      current = current[parts[i]];
    }
    
    current[parts[parts.length - 1]] = content;
    return true;
  }

  function buildAdvancedPlugin() {
    const pluginId = document.getElementById('advanced-plugin-id').value.trim() || 'plugin';
    
    // Validate structure
    const validation = validatePluginStructure(state.fileTree);
    if (!validation.valid) {
      showMessage(validation.error, 'error');
      return;
    }
    
    showMessage(`Valid entry point found: ${validation.entry}`, 'success');
    buildAndDownload(state.fileTree, sanitizeFilename(pluginId));
  }

  // ========================================
  // Archive Building
  // ========================================

  function buildAndDownload(fileTree, filename) {
    const zip = new JSZip();
    
    // Add files recursively
    addToZip(zip, fileTree, '');
    
    // Generate blob and trigger download
    zip.generateAsync({ type: 'blob' })
      .then(blob => {
        saveAs(blob, `${filename}.ben`);
        showMessage(`Successfully created ${filename}.ben`, 'success');
      })
      .catch(err => {
        showMessage(`Failed to create archive: ${err.message}`, 'error');
      });
  }

  function addToZip(zip, tree, path) {
    for (const [name, content] of Object.entries(tree)) {
      const fullPath = path ? `${path}/${name}` : name;
      
      if (typeof content === 'object') {
        // Folder
        const folder = zip.folder(fullPath);
        addToZip(zip, content, fullPath);
      } else {
        // File
        zip.file(fullPath, content);
      }
    }
  }

  // ========================================
  // Modal Functions
  // ========================================

  function showPreviewModal(code) {
    const modal = document.getElementById('preview-modal');
    const codeElement = document.getElementById('preview-code');
    
    codeElement.textContent = code;
    modal.classList.add('active');
  }

  function closePreviewModal() {
    document.getElementById('preview-modal').classList.remove('active');
  }

  // ========================================
  // Tab Management
  // ========================================

  function switchTab(tabName) {
    // Update buttons
    document.querySelectorAll('.tab-button').forEach(btn => {
      btn.classList.toggle('active', btn.dataset.tab === tabName);
    });
    
    // Update content
    document.querySelectorAll('.tab-content').forEach(content => {
      content.classList.toggle('active', content.id === `${tabName}-tab`);
    });
    
    state.currentTab = tabName;
  }

  // ========================================
  // Event Listeners
  // ========================================

  document.addEventListener('DOMContentLoaded', () => {
    // Tab switching
    document.querySelectorAll('.tab-button').forEach(btn => {
      btn.addEventListener('click', () => switchTab(btn.dataset.tab));
    });
    
    // Quick Builder
    document.getElementById('build-quick').addEventListener('click', buildQuickPlugin);
    document.getElementById('preview-quick').addEventListener('click', previewQuickPlugin);
    
    // Advanced Builder
    document.getElementById('add-file').addEventListener('click', addFile);
    document.getElementById('add-folder').addEventListener('click', addFolder);
    document.getElementById('upload-files').addEventListener('click', uploadFiles);
    document.getElementById('file-upload-input').addEventListener('change', handleFileUpload);
    document.getElementById('save-file').addEventListener('click', saveFile);
    document.getElementById('cancel-edit').addEventListener('click', cancelEdit);
    document.getElementById('build-advanced').addEventListener('click', buildAdvancedPlugin);
    
    // Modal
    document.querySelector('.modal-close').addEventListener('click', closePreviewModal);
    document.getElementById('preview-modal').addEventListener('click', (e) => {
      if (e.target.id === 'preview-modal') {
        closePreviewModal();
      }
    });
    
    // Initialize file tree
    renderFileTree();
  });

})();
